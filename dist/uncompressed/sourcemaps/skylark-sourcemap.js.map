{"version":3,"sources":["skylark-sourcemap.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"../skylark-sourcemap.js","sourcesContent":["define('skylark-sourcemap/util',[], function () {\n    'use strict';\n \n    function getArg(aArgs, aName, aDefaultValue) {\n        if (aName in aArgs) {\n            return aArgs[aName];\n        } else if (arguments.length === 3) {\n            return aDefaultValue;\n        } else {\n            throw new Error('\"' + aName + '\" is a required argument.');\n        }\n    }\n    var urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.-]*)(?::(\\d+))?(.*)$/;\n    var dataUrlRegexp = /^data:.+\\,.+$/;\n    function urlParse(aUrl) {\n        var match = aUrl.match(urlRegexp);\n        if (!match) {\n            return null;\n        }\n        return {\n            scheme: match[1],\n            auth: match[2],\n            host: match[3],\n            port: match[4],\n            path: match[5]\n        };\n    }\n    function urlGenerate(aParsedUrl) {\n        var url = '';\n        if (aParsedUrl.scheme) {\n            url += aParsedUrl.scheme + ':';\n        }\n        url += '//';\n        if (aParsedUrl.auth) {\n            url += aParsedUrl.auth + '@';\n        }\n        if (aParsedUrl.host) {\n            url += aParsedUrl.host;\n        }\n        if (aParsedUrl.port) {\n            url += ':' + aParsedUrl.port;\n        }\n        if (aParsedUrl.path) {\n            url += aParsedUrl.path;\n        }\n        return url;\n    }\n    function normalize(aPath) {\n        var path = aPath;\n        var url = urlParse(aPath);\n        if (url) {\n            if (!url.path) {\n                return aPath;\n            }\n            path = url.path;\n        }\n        var isAbsPath = isAbsolute(path);\n        var parts = path.split(/\\/+/);\n        for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {\n            part = parts[i];\n            if (part === '.') {\n                parts.splice(i, 1);\n            } else if (part === '..') {\n                up++;\n            } else if (up > 0) {\n                if (part === '') {\n                    parts.splice(i + 1, up);\n                    up = 0;\n                } else {\n                    parts.splice(i, 2);\n                    up--;\n                }\n            }\n        }\n        path = parts.join('/');\n        if (path === '') {\n            path = isAbsPath ? '/' : '.';\n        }\n        if (url) {\n            url.path = path;\n            return urlGenerate(url);\n        }\n        return path;\n    }\n    function join(aRoot, aPath) {\n        if (aRoot === '') {\n            aRoot = '.';\n        }\n        if (aPath === '') {\n            aPath = '.';\n        }\n        var aPathUrl = urlParse(aPath);\n        var aRootUrl = urlParse(aRoot);\n        if (aRootUrl) {\n            aRoot = aRootUrl.path || '/';\n        }\n        if (aPathUrl && !aPathUrl.scheme) {\n            if (aRootUrl) {\n                aPathUrl.scheme = aRootUrl.scheme;\n            }\n            return urlGenerate(aPathUrl);\n        }\n        if (aPathUrl || aPath.match(dataUrlRegexp)) {\n            return aPath;\n        }\n        if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n            aRootUrl.host = aPath;\n            return urlGenerate(aRootUrl);\n        }\n        var joined = aPath.charAt(0) === '/' ? aPath : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);\n        if (aRootUrl) {\n            aRootUrl.path = joined;\n            return urlGenerate(aRootUrl);\n        }\n        return joined;\n    }\n    function isAbsolute(aPath) {\n        return aPath.charAt(0) === '/' || urlRegexp.test(aPath);\n    }\n    function relative(aRoot, aPath) {\n        if (aRoot === '') {\n            aRoot = '.';\n        }\n        aRoot = aRoot.replace(/\\/$/, '');\n        var level = 0;\n        while (aPath.indexOf(aRoot + '/') !== 0) {\n            var index = aRoot.lastIndexOf('/');\n            if (index < 0) {\n                return aPath;\n            }\n            aRoot = aRoot.slice(0, index);\n            if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n                return aPath;\n            }\n            ++level;\n        }\n        return Array(level + 1).join('../') + aPath.substr(aRoot.length + 1);\n    }\n    var supportsNullProto = function () {\n        var obj = Object.create(null);\n        return !('__proto__' in obj);\n    }();\n    function identity(s) {\n        return s;\n    }\n    function toSetString(aStr) {\n        if (isProtoString(aStr)) {\n            return '$' + aStr;\n        }\n        return aStr;\n    }\n    function fromSetString(aStr) {\n        if (isProtoString(aStr)) {\n            return aStr.slice(1);\n        }\n        return aStr;\n    }\n    function isProtoString(s) {\n        if (!s) {\n            return false;\n        }\n        var length = s.length;\n        if (length < 9) {\n            return false;\n        }\n        if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {\n            return false;\n        }\n        for (var i = length - 10; i >= 0; i--) {\n            if (s.charCodeAt(i) !== 36) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n        var cmp = strcmp(mappingA.source, mappingB.source);\n        if (cmp !== 0) {\n            return cmp;\n        }\n        cmp = mappingA.originalLine - mappingB.originalLine;\n        if (cmp !== 0) {\n            return cmp;\n        }\n        cmp = mappingA.originalColumn - mappingB.originalColumn;\n        if (cmp !== 0 || onlyCompareOriginal) {\n            return cmp;\n        }\n        cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n        if (cmp !== 0) {\n            return cmp;\n        }\n        cmp = mappingA.generatedLine - mappingB.generatedLine;\n        if (cmp !== 0) {\n            return cmp;\n        }\n        return strcmp(mappingA.name, mappingB.name);\n    }\n    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n        var cmp = mappingA.generatedLine - mappingB.generatedLine;\n        if (cmp !== 0) {\n            return cmp;\n        }\n        cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n        if (cmp !== 0 || onlyCompareGenerated) {\n            return cmp;\n        }\n        cmp = strcmp(mappingA.source, mappingB.source);\n        if (cmp !== 0) {\n            return cmp;\n        }\n        cmp = mappingA.originalLine - mappingB.originalLine;\n        if (cmp !== 0) {\n            return cmp;\n        }\n        cmp = mappingA.originalColumn - mappingB.originalColumn;\n        if (cmp !== 0) {\n            return cmp;\n        }\n        return strcmp(mappingA.name, mappingB.name);\n    }\n    function strcmp(aStr1, aStr2) {\n        if (aStr1 === aStr2) {\n            return 0;\n        }\n        if (aStr1 === null) {\n            return 1;\n        }\n        if (aStr2 === null) {\n            return -1;\n        }\n        if (aStr1 > aStr2) {\n            return 1;\n        }\n        return -1;\n    }\n    function compareByGeneratedPositionsInflated(mappingA, mappingB) {\n        var cmp = mappingA.generatedLine - mappingB.generatedLine;\n        if (cmp !== 0) {\n            return cmp;\n        }\n        cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n        if (cmp !== 0) {\n            return cmp;\n        }\n        cmp = strcmp(mappingA.source, mappingB.source);\n        if (cmp !== 0) {\n            return cmp;\n        }\n        cmp = mappingA.originalLine - mappingB.originalLine;\n        if (cmp !== 0) {\n            return cmp;\n        }\n        cmp = mappingA.originalColumn - mappingB.originalColumn;\n        if (cmp !== 0) {\n            return cmp;\n        }\n        return strcmp(mappingA.name, mappingB.name);\n    }\n    function parseSourceMapInput(str) {\n        return JSON.parse(str.replace(/^\\)]}'[^\\n]*\\n/, ''));\n    }\n    function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {\n        sourceURL = sourceURL || '';\n        if (sourceRoot) {\n            if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {\n                sourceRoot += '/';\n            }\n            sourceURL = sourceRoot + sourceURL;\n        }\n        if (sourceMapURL) {\n            var parsed = urlParse(sourceMapURL);\n            if (!parsed) {\n                throw new Error('sourceMapURL could not be parsed');\n            }\n            if (parsed.path) {\n                var index = parsed.path.lastIndexOf('/');\n                if (index >= 0) {\n                    parsed.path = parsed.path.substring(0, index + 1);\n                }\n            }\n            sourceURL = join(urlGenerate(parsed), sourceURL);\n        }\n        return normalize(sourceURL);\n    }\n\n    return {\n        toSetString : supportsNullProto ? identity : toSetString,\n        fromSetString : supportsNullProto ? identity : fromSetString,\n        compareByOriginalPositions,\n\n        isAbsolute,\n        compareByGeneratedPositionsDeflated,\n        compareByGeneratedPositionsInflated,\n        parseSourceMapInput,\n        getArg,\n        urlParse,\n        urlGenerate,\n        normalize,\n        join,\n        relative,\n        computeSourceURL\n    };\n});\ndefine('skylark-sourcemap/array-set',['./util'], function (util) {\n    'use strict';\n    var has = Object.prototype.hasOwnProperty;\n    var hasNativeMap = typeof Map !== 'undefined';\n    function ArraySet() {\n        this._array = [];\n        this._set = hasNativeMap ? new Map() : Object.create(null);\n    }\n    ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {\n        var set = new ArraySet();\n        for (var i = 0, len = aArray.length; i < len; i++) {\n            set.add(aArray[i], aAllowDuplicates);\n        }\n        return set;\n    };\n    ArraySet.prototype.size = function ArraySet_size() {\n        return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;\n    };\n    ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {\n        var sStr = hasNativeMap ? aStr : util.toSetString(aStr);\n        var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);\n        var idx = this._array.length;\n        if (!isDuplicate || aAllowDuplicates) {\n            this._array.push(aStr);\n        }\n        if (!isDuplicate) {\n            if (hasNativeMap) {\n                this._set.set(aStr, idx);\n            } else {\n                this._set[sStr] = idx;\n            }\n        }\n    };\n    ArraySet.prototype.has = function ArraySet_has(aStr) {\n        if (hasNativeMap) {\n            return this._set.has(aStr);\n        } else {\n            var sStr = util.toSetString(aStr);\n            return has.call(this._set, sStr);\n        }\n    };\n    ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {\n        if (hasNativeMap) {\n            var idx = this._set.get(aStr);\n            if (idx >= 0) {\n                return idx;\n            }\n        } else {\n            var sStr = util.toSetString(aStr);\n            if (has.call(this._set, sStr)) {\n                return this._set[sStr];\n            }\n        }\n        throw new Error('\"' + aStr + '\" is not in the set.');\n    };\n    ArraySet.prototype.at = function ArraySet_at(aIdx) {\n        if (aIdx >= 0 && aIdx < this._array.length) {\n            return this._array[aIdx];\n        }\n        throw new Error('No element indexed by ' + aIdx);\n    };\n    ArraySet.prototype.toArray = function ArraySet_toArray() {\n        return this._array.slice();\n    };\n    \n    return ArraySet;\n});\ndefine('skylark-sourcemap/base64',[], function () {\n    'use strict';\n    var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');\n    function encode(number) {\n        if (0 <= number && number < intToCharMap.length) {\n            return intToCharMap[number];\n        }\n        throw new TypeError('Must be between 0 and 63: ' + number);\n    }\n\n    function decode(charCode) {\n        var bigA = 65;\n        var bigZ = 90;\n        var littleA = 97;\n        var littleZ = 122;\n        var zero = 48;\n        var nine = 57;\n        var plus = 43;\n        var slash = 47;\n        var littleOffset = 26;\n        var numberOffset = 52;\n        if (bigA <= charCode && charCode <= bigZ) {\n            return charCode - bigA;\n        }\n        if (littleA <= charCode && charCode <= littleZ) {\n            return charCode - littleA + littleOffset;\n        }\n        if (zero <= charCode && charCode <= nine) {\n            return charCode - zero + numberOffset;\n        }\n        if (charCode == plus) {\n            return 62;\n        }\n        if (charCode == slash) {\n            return 63;\n        }\n        return -1;\n    }\n    \n    return {\n        encode,\n        decode\n    }\n});\ndefine('skylark-sourcemap/base64-vlq',['./base64'], function (base64) {\n    'use strict';\n    var VLQ_BASE_SHIFT = 5;\n    var VLQ_BASE = 1 << VLQ_BASE_SHIFT;\n    var VLQ_BASE_MASK = VLQ_BASE - 1;\n    var VLQ_CONTINUATION_BIT = VLQ_BASE;\n    function toVLQSigned(aValue) {\n        return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;\n    }\n    function fromVLQSigned(aValue) {\n        var isNegative = (aValue & 1) === 1;\n        var shifted = aValue >> 1;\n        return isNegative ? -shifted : shifted;\n    }\n    var encode = function base64VLQ_encode(aValue) {\n        var encoded = '';\n        var digit;\n        var vlq = toVLQSigned(aValue);\n        do {\n            digit = vlq & VLQ_BASE_MASK;\n            vlq >>>= VLQ_BASE_SHIFT;\n            if (vlq > 0) {\n                digit |= VLQ_CONTINUATION_BIT;\n            }\n            encoded += base64.encode(digit);\n        } while (vlq > 0);\n        return encoded;\n    };\n    var decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {\n        var strLen = aStr.length;\n        var result = 0;\n        var shift = 0;\n        var continuation, digit;\n        do {\n            if (aIndex >= strLen) {\n                throw new Error('Expected more digits in base 64 VLQ value.');\n            }\n            digit = base64.decode(aStr.charCodeAt(aIndex++));\n            if (digit === -1) {\n                throw new Error('Invalid base64 digit: ' + aStr.charAt(aIndex - 1));\n            }\n            continuation = !!(digit & VLQ_CONTINUATION_BIT);\n            digit &= VLQ_BASE_MASK;\n            result = result + (digit << shift);\n            shift += VLQ_BASE_SHIFT;\n        } while (continuation);\n        aOutParam.value = fromVLQSigned(result);\n        aOutParam.rest = aIndex;\n    };\n\n    return {\n        encode,\n        decode\n    }\n\n});\ndefine('skylark-sourcemap/binary-search',[], function () {\n    'use strict';\n\n    const  GREATEST_LOWER_BOUND = 1;\n    const LEAST_UPPER_BOUND = 2;\n\n    function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {\n        var mid = Math.floor((aHigh - aLow) / 2) + aLow;\n        var cmp = aCompare(aNeedle, aHaystack[mid], true);\n        if (cmp === 0) {\n            return mid;\n        } else if (cmp > 0) {\n            if (aHigh - mid > 1) {\n                return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);\n            }\n            if (aBias == LEAST_UPPER_BOUND) {\n                return aHigh < aHaystack.length ? aHigh : -1;\n            } else {\n                return mid;\n            }\n        } else {\n            if (mid - aLow > 1) {\n                return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);\n            }\n            if (aBias == LEAST_UPPER_BOUND) {\n                return mid;\n            } else {\n                return aLow < 0 ? -1 : aLow;\n            }\n        }\n    }\n     function search(aNeedle, aHaystack, aCompare, aBias) {\n        if (aHaystack.length === 0) {\n            return -1;\n        }\n        var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || GREATEST_LOWER_BOUND);\n        if (index < 0) {\n            return -1;\n        }\n        while (index - 1 >= 0) {\n            if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {\n                break;\n            }\n            --index;\n        }\n        return index;\n    };\n\n    return {\n      GREATEST_LOWER_BOUND,\n      LEAST_UPPER_BOUND,\n      search\n    }\n});\ndefine('skylark-sourcemap/mapping-list',['./util'], function (util) {\n    'use strict';\n\n\n    function generatedPositionAfter(mappingA, mappingB) {\n        var lineA = mappingA.generatedLine;\n        var lineB = mappingB.generatedLine;\n        var columnA = mappingA.generatedColumn;\n        var columnB = mappingB.generatedColumn;\n        return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;\n    }\n\n    function MappingList() {\n        this._array = [];\n        this._sorted = true;\n        this._last = {\n            generatedLine: -1,\n            generatedColumn: 0\n        };\n    }\n\n    MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {\n        this._array.forEach(aCallback, aThisArg);\n    };\n    MappingList.prototype.add = function MappingList_add(aMapping) {\n        if (generatedPositionAfter(this._last, aMapping)) {\n            this._last = aMapping;\n            this._array.push(aMapping);\n        } else {\n            this._sorted = false;\n            this._array.push(aMapping);\n        }\n    };\n\n    MappingList.prototype.toArray = function MappingList_toArray() {\n        if (!this._sorted) {\n            this._array.sort(util.compareByGeneratedPositionsInflated);\n            this._sorted = true;\n        }\n        return this._array;\n    };\n\n    return  MappingList;\n});\ndefine('skylark-sourcemap/quick-sort',[], function () {\n    'use strict';\n\n    function swap(ary, x, y) {\n        var temp = ary[x];\n        ary[x] = ary[y];\n        ary[y] = temp;\n    }\n    function randomIntInRange(low, high) {\n        return Math.round(low + Math.random() * (high - low));\n    }\n    function doQuickSort(ary, comparator, p, r) {\n        if (p < r) {\n            var pivotIndex = randomIntInRange(p, r);\n            var i = p - 1;\n            swap(ary, pivotIndex, r);\n            var pivot = ary[r];\n            for (var j = p; j < r; j++) {\n                if (comparator(ary[j], pivot) <= 0) {\n                    i += 1;\n                    swap(ary, i, j);\n                }\n            }\n            swap(ary, i + 1, j);\n            var q = i + 1;\n            doQuickSort(ary, comparator, p, q - 1);\n            doQuickSort(ary, comparator, q + 1, r);\n        }\n    }\n    \n    function quickSort(ary, comparator) {\n        doQuickSort(ary, comparator, 0, ary.length - 1);\n    }\n\n    return {\n        quickSort\n    }\n});\ndefine('skylark-sourcemap/source-map-consumer',[\n    './util',\n    './binary-search',\n    './array-set',\n    './base64-vlq',\n    './quick-sort'\n], function (util, binarySearch, ArraySet, base64VLQ, quickSort) {\n    'use strict';\n\n    function SourceMapConsumer(aSourceMap, aSourceMapURL) {\n        var sourceMap = aSourceMap;\n        if (typeof aSourceMap === 'string') {\n            sourceMap = util.parseSourceMapInput(aSourceMap);\n        }\n        return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);\n    }\n\n    SourceMapConsumer.fromSourceMap = function (aSourceMap, aSourceMapURL) {\n        return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);\n    };\n\n    SourceMapConsumer.prototype._version = 3;\n\n    SourceMapConsumer.prototype.__generatedMappings = null;\n\n    Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {\n        configurable: true,\n        enumerable: true,\n        get: function () {\n            if (!this.__generatedMappings) {\n                this._parseMappings(this._mappings, this.sourceRoot);\n            }\n            return this.__generatedMappings;\n        }\n    });\n\n    SourceMapConsumer.prototype.__originalMappings = null;\n\n    Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {\n        configurable: true,\n        enumerable: true,\n        get: function () {\n            if (!this.__originalMappings) {\n                this._parseMappings(this._mappings, this.sourceRoot);\n            }\n            return this.__originalMappings;\n        }\n    });\n\n    SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {\n        var c = aStr.charAt(index);\n        return c === ';' || c === ',';\n    };\n\n    SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n        throw new Error('Subclasses must implement _parseMappings');\n    };\n\n    SourceMapConsumer.GENERATED_ORDER = 1;\n    SourceMapConsumer.ORIGINAL_ORDER = 2;\n    SourceMapConsumer.GREATEST_LOWER_BOUND = 1;\n    SourceMapConsumer.LEAST_UPPER_BOUND = 2;\n    SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {\n        var context = aContext || null;\n        var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n        var mappings;\n        switch (order) {\n        case SourceMapConsumer.GENERATED_ORDER:\n            mappings = this._generatedMappings;\n            break;\n        case SourceMapConsumer.ORIGINAL_ORDER:\n            mappings = this._originalMappings;\n            break;\n        default:\n            throw new Error('Unknown order of iteration.');\n        }\n        var sourceRoot = this.sourceRoot;\n        mappings.map(function (mapping) {\n            var source = mapping.source === null ? null : this._sources.at(mapping.source);\n            source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);\n            return {\n                source: source,\n                generatedLine: mapping.generatedLine,\n                generatedColumn: mapping.generatedColumn,\n                originalLine: mapping.originalLine,\n                originalColumn: mapping.originalColumn,\n                name: mapping.name === null ? null : this._names.at(mapping.name)\n            };\n        }, this).forEach(aCallback, context);\n    };\n    SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {\n        var line = util.getArg(aArgs, 'line');\n        var needle = {\n            source: util.getArg(aArgs, 'source'),\n            originalLine: line,\n            originalColumn: util.getArg(aArgs, 'column', 0)\n        };\n        needle.source = this._findSourceIndex(needle.source);\n        if (needle.source < 0) {\n            return [];\n        }\n        var mappings = [];\n        var index = this._findMapping(needle, this._originalMappings, 'originalLine', 'originalColumn', util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);\n        if (index >= 0) {\n            var mapping = this._originalMappings[index];\n            if (aArgs.column === undefined) {\n                var originalLine = mapping.originalLine;\n                while (mapping && mapping.originalLine === originalLine) {\n                    mappings.push({\n                        line: util.getArg(mapping, 'generatedLine', null),\n                        column: util.getArg(mapping, 'generatedColumn', null),\n                        lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n                    });\n                    mapping = this._originalMappings[++index];\n                }\n            } else {\n                var originalColumn = mapping.originalColumn;\n                while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {\n                    mappings.push({\n                        line: util.getArg(mapping, 'generatedLine', null),\n                        column: util.getArg(mapping, 'generatedColumn', null),\n                        lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n                    });\n                    mapping = this._originalMappings[++index];\n                }\n            }\n        }\n        return mappings;\n    };\n\n    function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {\n        var sourceMap = aSourceMap;\n        if (typeof aSourceMap === 'string') {\n            sourceMap = util.parseSourceMapInput(aSourceMap);\n        }\n        var version = util.getArg(sourceMap, 'version');\n        var sources = util.getArg(sourceMap, 'sources');\n        var names = util.getArg(sourceMap, 'names', []);\n        var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);\n        var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);\n        var mappings = util.getArg(sourceMap, 'mappings');\n        var file = util.getArg(sourceMap, 'file', null);\n        if (version != this._version) {\n            throw new Error('Unsupported version: ' + version);\n        }\n        if (sourceRoot) {\n            sourceRoot = util.normalize(sourceRoot);\n        }\n        sources = sources.map(String).map(util.normalize).map(function (source) {\n            return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;\n        });\n        this._names = ArraySet.fromArray(names.map(String), true);\n        this._sources = ArraySet.fromArray(sources, true);\n        this._absoluteSources = this._sources.toArray().map(function (s) {\n            return util.computeSourceURL(sourceRoot, s, aSourceMapURL);\n        });\n        this.sourceRoot = sourceRoot;\n        this.sourcesContent = sourcesContent;\n        this._mappings = mappings;\n        this._sourceMapURL = aSourceMapURL;\n        this.file = file;\n    }\n    BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\n    BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\n    BasicSourceMapConsumer.prototype._findSourceIndex = function (aSource) {\n        var relativeSource = aSource;\n        if (this.sourceRoot != null) {\n            relativeSource = util.relative(this.sourceRoot, relativeSource);\n        }\n        if (this._sources.has(relativeSource)) {\n            return this._sources.indexOf(relativeSource);\n        }\n        var i;\n        for (i = 0; i < this._absoluteSources.length; ++i) {\n            if (this._absoluteSources[i] == aSource) {\n                return i;\n            }\n        }\n        return -1;\n    };\n    BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {\n        var smc = Object.create(BasicSourceMapConsumer.prototype);\n        var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);\n        var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);\n        smc.sourceRoot = aSourceMap._sourceRoot;\n        smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);\n        smc.file = aSourceMap._file;\n        smc._sourceMapURL = aSourceMapURL;\n        smc._absoluteSources = smc._sources.toArray().map(function (s) {\n            return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);\n        });\n        var generatedMappings = aSourceMap._mappings.toArray().slice();\n        var destGeneratedMappings = smc.__generatedMappings = [];\n        var destOriginalMappings = smc.__originalMappings = [];\n        for (var i = 0, length = generatedMappings.length; i < length; i++) {\n            var srcMapping = generatedMappings[i];\n            var destMapping = new Mapping();\n            destMapping.generatedLine = srcMapping.generatedLine;\n            destMapping.generatedColumn = srcMapping.generatedColumn;\n            if (srcMapping.source) {\n                destMapping.source = sources.indexOf(srcMapping.source);\n                destMapping.originalLine = srcMapping.originalLine;\n                destMapping.originalColumn = srcMapping.originalColumn;\n                if (srcMapping.name) {\n                    destMapping.name = names.indexOf(srcMapping.name);\n                }\n                destOriginalMappings.push(destMapping);\n            }\n            destGeneratedMappings.push(destMapping);\n        }\n        quickSort(smc.__originalMappings, util.compareByOriginalPositions);\n        return smc;\n    };\n    BasicSourceMapConsumer.prototype._version = 3;\n    Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {\n        get: function () {\n            return this._absoluteSources.slice();\n        }\n    });\n    function Mapping() {\n        this.generatedLine = 0;\n        this.generatedColumn = 0;\n        this.source = null;\n        this.originalLine = null;\n        this.originalColumn = null;\n        this.name = null;\n    }\n    BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n        var generatedLine = 1;\n        var previousGeneratedColumn = 0;\n        var previousOriginalLine = 0;\n        var previousOriginalColumn = 0;\n        var previousSource = 0;\n        var previousName = 0;\n        var length = aStr.length;\n        var index = 0;\n        var cachedSegments = {};\n        var temp = {};\n        var originalMappings = [];\n        var generatedMappings = [];\n        var mapping, str, segment, end, value;\n        while (index < length) {\n            if (aStr.charAt(index) === ';') {\n                generatedLine++;\n                index++;\n                previousGeneratedColumn = 0;\n            } else if (aStr.charAt(index) === ',') {\n                index++;\n            } else {\n                mapping = new Mapping();\n                mapping.generatedLine = generatedLine;\n                for (end = index; end < length; end++) {\n                    if (this._charIsMappingSeparator(aStr, end)) {\n                        break;\n                    }\n                }\n                str = aStr.slice(index, end);\n                segment = cachedSegments[str];\n                if (segment) {\n                    index += str.length;\n                } else {\n                    segment = [];\n                    while (index < end) {\n                        base64VLQ.decode(aStr, index, temp);\n                        value = temp.value;\n                        index = temp.rest;\n                        segment.push(value);\n                    }\n                    if (segment.length === 2) {\n                        throw new Error('Found a source, but no line and column');\n                    }\n                    if (segment.length === 3) {\n                        throw new Error('Found a source and line, but no column');\n                    }\n                    cachedSegments[str] = segment;\n                }\n                mapping.generatedColumn = previousGeneratedColumn + segment[0];\n                previousGeneratedColumn = mapping.generatedColumn;\n                if (segment.length > 1) {\n                    mapping.source = previousSource + segment[1];\n                    previousSource += segment[1];\n                    mapping.originalLine = previousOriginalLine + segment[2];\n                    previousOriginalLine = mapping.originalLine;\n                    mapping.originalLine += 1;\n                    mapping.originalColumn = previousOriginalColumn + segment[3];\n                    previousOriginalColumn = mapping.originalColumn;\n                    if (segment.length > 4) {\n                        mapping.name = previousName + segment[4];\n                        previousName += segment[4];\n                    }\n                }\n                generatedMappings.push(mapping);\n                if (typeof mapping.originalLine === 'number') {\n                    originalMappings.push(mapping);\n                }\n            }\n        }\n        quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);\n        this.__generatedMappings = generatedMappings;\n        quickSort(originalMappings, util.compareByOriginalPositions);\n        this.__originalMappings = originalMappings;\n    };\n    BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {\n        if (aNeedle[aLineName] <= 0) {\n            throw new TypeError('Line must be greater than or equal to 1, got ' + aNeedle[aLineName]);\n        }\n        if (aNeedle[aColumnName] < 0) {\n            throw new TypeError('Column must be greater than or equal to 0, got ' + aNeedle[aColumnName]);\n        }\n        return binarySearch.search(aNeedle, aMappings, aComparator, aBias);\n    };\n    BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {\n        for (var index = 0; index < this._generatedMappings.length; ++index) {\n            var mapping = this._generatedMappings[index];\n            if (index + 1 < this._generatedMappings.length) {\n                var nextMapping = this._generatedMappings[index + 1];\n                if (mapping.generatedLine === nextMapping.generatedLine) {\n                    mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;\n                    continue;\n                }\n            }\n            mapping.lastGeneratedColumn = Infinity;\n        }\n    };\n    BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {\n        var needle = {\n            generatedLine: util.getArg(aArgs, 'line'),\n            generatedColumn: util.getArg(aArgs, 'column')\n        };\n        var index = this._findMapping(needle, this._generatedMappings, 'generatedLine', 'generatedColumn', util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));\n        if (index >= 0) {\n            var mapping = this._generatedMappings[index];\n            if (mapping.generatedLine === needle.generatedLine) {\n                var source = util.getArg(mapping, 'source', null);\n                if (source !== null) {\n                    source = this._sources.at(source);\n                    source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);\n                }\n                var name = util.getArg(mapping, 'name', null);\n                if (name !== null) {\n                    name = this._names.at(name);\n                }\n                return {\n                    source: source,\n                    line: util.getArg(mapping, 'originalLine', null),\n                    column: util.getArg(mapping, 'originalColumn', null),\n                    name: name\n                };\n            }\n        }\n        return {\n            source: null,\n            line: null,\n            column: null,\n            name: null\n        };\n    };\n    BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {\n        if (!this.sourcesContent) {\n            return false;\n        }\n        return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function (sc) {\n            return sc == null;\n        });\n    };\n    BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n        if (!this.sourcesContent) {\n            return null;\n        }\n        var index = this._findSourceIndex(aSource);\n        if (index >= 0) {\n            return this.sourcesContent[index];\n        }\n        var relativeSource = aSource;\n        if (this.sourceRoot != null) {\n            relativeSource = util.relative(this.sourceRoot, relativeSource);\n        }\n        var url;\n        if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {\n            var fileUriAbsPath = relativeSource.replace(/^file:\\/\\//, '');\n            if (url.scheme == 'file' && this._sources.has(fileUriAbsPath)) {\n                return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];\n            }\n            if ((!url.path || url.path == '/') && this._sources.has('/' + relativeSource)) {\n                return this.sourcesContent[this._sources.indexOf('/' + relativeSource)];\n            }\n        }\n        if (nullOnMissing) {\n            return null;\n        } else {\n            throw new Error('\"' + relativeSource + '\" is not in the SourceMap.');\n        }\n    };\n    BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {\n        var source = util.getArg(aArgs, 'source');\n        source = this._findSourceIndex(source);\n        if (source < 0) {\n            return {\n                line: null,\n                column: null,\n                lastColumn: null\n            };\n        }\n        var needle = {\n            source: source,\n            originalLine: util.getArg(aArgs, 'line'),\n            originalColumn: util.getArg(aArgs, 'column')\n        };\n        var index = this._findMapping(needle, this._originalMappings, 'originalLine', 'originalColumn', util.compareByOriginalPositions, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));\n        if (index >= 0) {\n            var mapping = this._originalMappings[index];\n            if (mapping.source === needle.source) {\n                return {\n                    line: util.getArg(mapping, 'generatedLine', null),\n                    column: util.getArg(mapping, 'generatedColumn', null),\n                    lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n                };\n            }\n        }\n        return {\n            line: null,\n            column: null,\n            lastColumn: null\n        };\n    };\n\n    function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {\n        var sourceMap = aSourceMap;\n        if (typeof aSourceMap === 'string') {\n            sourceMap = util.parseSourceMapInput(aSourceMap);\n        }\n        var version = util.getArg(sourceMap, 'version');\n        var sections = util.getArg(sourceMap, 'sections');\n        if (version != this._version) {\n            throw new Error('Unsupported version: ' + version);\n        }\n        this._sources = new ArraySet();\n        this._names = new ArraySet();\n        var lastOffset = {\n            line: -1,\n            column: 0\n        };\n        this._sections = sections.map(function (s) {\n            if (s.url) {\n                throw new Error('Support for url field in sections not implemented.');\n            }\n            var offset = util.getArg(s, 'offset');\n            var offsetLine = util.getArg(offset, 'line');\n            var offsetColumn = util.getArg(offset, 'column');\n            if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {\n                throw new Error('Section offsets must be ordered and non-overlapping.');\n            }\n            lastOffset = offset;\n            return {\n                generatedOffset: {\n                    generatedLine: offsetLine + 1,\n                    generatedColumn: offsetColumn + 1\n                },\n                consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)\n            };\n        });\n    }\n    IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\n    IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;\n    IndexedSourceMapConsumer.prototype._version = 3;\n    Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {\n        get: function () {\n            var sources = [];\n            for (var i = 0; i < this._sections.length; i++) {\n                for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {\n                    sources.push(this._sections[i].consumer.sources[j]);\n                }\n            }\n            return sources;\n        }\n    });\n    IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {\n        var needle = {\n            generatedLine: util.getArg(aArgs, 'line'),\n            generatedColumn: util.getArg(aArgs, 'column')\n        };\n        var sectionIndex = binarySearch.search(needle, this._sections, function (needle, section) {\n            var cmp = needle.generatedLine - section.generatedOffset.generatedLine;\n            if (cmp) {\n                return cmp;\n            }\n            return needle.generatedColumn - section.generatedOffset.generatedColumn;\n        });\n        var section = this._sections[sectionIndex];\n        if (!section) {\n            return {\n                source: null,\n                line: null,\n                column: null,\n                name: null\n            };\n        }\n        return section.consumer.originalPositionFor({\n            line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),\n            column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),\n            bias: aArgs.bias\n        });\n    };\n    IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {\n        return this._sections.every(function (s) {\n            return s.consumer.hasContentsOfAllSources();\n        });\n    };\n    IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n        for (var i = 0; i < this._sections.length; i++) {\n            var section = this._sections[i];\n            var content = section.consumer.sourceContentFor(aSource, true);\n            if (content) {\n                return content;\n            }\n        }\n        if (nullOnMissing) {\n            return null;\n        } else {\n            throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n        }\n    };\n    IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {\n        for (var i = 0; i < this._sections.length; i++) {\n            var section = this._sections[i];\n            if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {\n                continue;\n            }\n            var generatedPosition = section.consumer.generatedPositionFor(aArgs);\n            if (generatedPosition) {\n                var ret = {\n                    line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),\n                    column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)\n                };\n                return ret;\n            }\n        }\n        return {\n            line: null,\n            column: null\n        };\n    };\n    IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n        this.__generatedMappings = [];\n        this.__originalMappings = [];\n        for (var i = 0; i < this._sections.length; i++) {\n            var section = this._sections[i];\n            var sectionMappings = section.consumer._generatedMappings;\n            for (var j = 0; j < sectionMappings.length; j++) {\n                var mapping = sectionMappings[j];\n                var source = section.consumer._sources.at(mapping.source);\n                source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);\n                this._sources.add(source);\n                source = this._sources.indexOf(source);\n                var name = null;\n                if (mapping.name) {\n                    name = section.consumer._names.at(mapping.name);\n                    this._names.add(name);\n                    name = this._names.indexOf(name);\n                }\n                var adjustedMapping = {\n                    source: source,\n                    generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),\n                    generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),\n                    originalLine: mapping.originalLine,\n                    originalColumn: mapping.originalColumn,\n                    name: name\n                };\n                this.__generatedMappings.push(adjustedMapping);\n                if (typeof adjustedMapping.originalLine === 'number') {\n                    this.__originalMappings.push(adjustedMapping);\n                }\n            }\n        }\n        quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);\n        quickSort(this.__originalMappings, util.compareByOriginalPositions);\n    };\n\n    return {\n        SourceMapConsumer,\n        BasicSourceMapConsumer,\n        IndexedSourceMapConsumer\n    }\n});\ndefine('skylark-sourcemap/source-map-generator',[\n    './base64-vlq',\n    './util',\n    './array-set',\n    './mapping-list'\n], function (base64VLQ, util, ArraySet, MappingList) {\n    'use strict';\n\n    function SourceMapGenerator(aArgs) {\n        if (!aArgs) {\n            aArgs = {};\n        }\n        this._file = util.getArg(aArgs, 'file', null);\n        this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);\n        this._skipValidation = util.getArg(aArgs, 'skipValidation', false);\n        this._sources = new ArraySet();\n        this._names = new ArraySet();\n        this._mappings = new MappingList();\n        this._sourcesContents = null;\n    }\n    SourceMapGenerator.prototype._version = 3;\n    SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {\n        var sourceRoot = aSourceMapConsumer.sourceRoot;\n        var generator = new SourceMapGenerator({\n            file: aSourceMapConsumer.file,\n            sourceRoot: sourceRoot\n        });\n        aSourceMapConsumer.eachMapping(function (mapping) {\n            var newMapping = {\n                generated: {\n                    line: mapping.generatedLine,\n                    column: mapping.generatedColumn\n                }\n            };\n            if (mapping.source != null) {\n                newMapping.source = mapping.source;\n                if (sourceRoot != null) {\n                    newMapping.source = util.relative(sourceRoot, newMapping.source);\n                }\n                newMapping.original = {\n                    line: mapping.originalLine,\n                    column: mapping.originalColumn\n                };\n                if (mapping.name != null) {\n                    newMapping.name = mapping.name;\n                }\n            }\n            generator.addMapping(newMapping);\n        });\n        aSourceMapConsumer.sources.forEach(function (sourceFile) {\n            var sourceRelative = sourceFile;\n            if (sourceRoot !== null) {\n                sourceRelative = util.relative(sourceRoot, sourceFile);\n            }\n            if (!generator._sources.has(sourceRelative)) {\n                generator._sources.add(sourceRelative);\n            }\n            var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n            if (content != null) {\n                generator.setSourceContent(sourceFile, content);\n            }\n        });\n        return generator;\n    };\n    SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {\n        var generated = util.getArg(aArgs, 'generated');\n        var original = util.getArg(aArgs, 'original', null);\n        var source = util.getArg(aArgs, 'source', null);\n        var name = util.getArg(aArgs, 'name', null);\n        if (!this._skipValidation) {\n            this._validateMapping(generated, original, source, name);\n        }\n        if (source != null) {\n            source = String(source);\n            if (!this._sources.has(source)) {\n                this._sources.add(source);\n            }\n        }\n        if (name != null) {\n            name = String(name);\n            if (!this._names.has(name)) {\n                this._names.add(name);\n            }\n        }\n        this._mappings.add({\n            generatedLine: generated.line,\n            generatedColumn: generated.column,\n            originalLine: original != null && original.line,\n            originalColumn: original != null && original.column,\n            source: source,\n            name: name\n        });\n    };\n    SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {\n        var source = aSourceFile;\n        if (this._sourceRoot != null) {\n            source = util.relative(this._sourceRoot, source);\n        }\n        if (aSourceContent != null) {\n            if (!this._sourcesContents) {\n                this._sourcesContents = Object.create(null);\n            }\n            this._sourcesContents[util.toSetString(source)] = aSourceContent;\n        } else if (this._sourcesContents) {\n            delete this._sourcesContents[util.toSetString(source)];\n            if (Object.keys(this._sourcesContents).length === 0) {\n                this._sourcesContents = null;\n            }\n        }\n    };\n    SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {\n        var sourceFile = aSourceFile;\n        if (aSourceFile == null) {\n            if (aSourceMapConsumer.file == null) {\n                throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' + 'or the source map\\'s \"file\" property. Both were omitted.');\n            }\n            sourceFile = aSourceMapConsumer.file;\n        }\n        var sourceRoot = this._sourceRoot;\n        if (sourceRoot != null) {\n            sourceFile = util.relative(sourceRoot, sourceFile);\n        }\n        var newSources = new ArraySet();\n        var newNames = new ArraySet();\n        this._mappings.unsortedForEach(function (mapping) {\n            if (mapping.source === sourceFile && mapping.originalLine != null) {\n                var original = aSourceMapConsumer.originalPositionFor({\n                    line: mapping.originalLine,\n                    column: mapping.originalColumn\n                });\n                if (original.source != null) {\n                    mapping.source = original.source;\n                    if (aSourceMapPath != null) {\n                        mapping.source = util.join(aSourceMapPath, mapping.source);\n                    }\n                    if (sourceRoot != null) {\n                        mapping.source = util.relative(sourceRoot, mapping.source);\n                    }\n                    mapping.originalLine = original.line;\n                    mapping.originalColumn = original.column;\n                    if (original.name != null) {\n                        mapping.name = original.name;\n                    }\n                }\n            }\n            var source = mapping.source;\n            if (source != null && !newSources.has(source)) {\n                newSources.add(source);\n            }\n            var name = mapping.name;\n            if (name != null && !newNames.has(name)) {\n                newNames.add(name);\n            }\n        }, this);\n        this._sources = newSources;\n        this._names = newNames;\n        aSourceMapConsumer.sources.forEach(function (sourceFile) {\n            var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n            if (content != null) {\n                if (aSourceMapPath != null) {\n                    sourceFile = util.join(aSourceMapPath, sourceFile);\n                }\n                if (sourceRoot != null) {\n                    sourceFile = util.relative(sourceRoot, sourceFile);\n                }\n                this.setSourceContent(sourceFile, content);\n            }\n        }, this);\n    };\n    SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {\n        if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {\n            throw new Error('original.line and original.column are not numbers -- you probably meant to omit ' + 'the original mapping entirely and only map the generated position. If so, pass ' + 'null for the original mapping instead of an object with empty or null values.');\n        }\n        if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {\n            return;\n        } else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aOriginal && 'line' in aOriginal && 'column' in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {\n            return;\n        } else {\n            throw new Error('Invalid mapping: ' + JSON.stringify({\n                generated: aGenerated,\n                source: aSource,\n                original: aOriginal,\n                name: aName\n            }));\n        }\n    };\n    SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {\n        var previousGeneratedColumn = 0;\n        var previousGeneratedLine = 1;\n        var previousOriginalColumn = 0;\n        var previousOriginalLine = 0;\n        var previousName = 0;\n        var previousSource = 0;\n        var result = '';\n        var next;\n        var mapping;\n        var nameIdx;\n        var sourceIdx;\n        var mappings = this._mappings.toArray();\n        for (var i = 0, len = mappings.length; i < len; i++) {\n            mapping = mappings[i];\n            next = '';\n            if (mapping.generatedLine !== previousGeneratedLine) {\n                previousGeneratedColumn = 0;\n                while (mapping.generatedLine !== previousGeneratedLine) {\n                    next += ';';\n                    previousGeneratedLine++;\n                }\n            } else {\n                if (i > 0) {\n                    if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {\n                        continue;\n                    }\n                    next += ',';\n                }\n            }\n            next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);\n            previousGeneratedColumn = mapping.generatedColumn;\n            if (mapping.source != null) {\n                sourceIdx = this._sources.indexOf(mapping.source);\n                next += base64VLQ.encode(sourceIdx - previousSource);\n                previousSource = sourceIdx;\n                next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);\n                previousOriginalLine = mapping.originalLine - 1;\n                next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);\n                previousOriginalColumn = mapping.originalColumn;\n                if (mapping.name != null) {\n                    nameIdx = this._names.indexOf(mapping.name);\n                    next += base64VLQ.encode(nameIdx - previousName);\n                    previousName = nameIdx;\n                }\n            }\n            result += next;\n        }\n        return result;\n    };\n    SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {\n        return aSources.map(function (source) {\n            if (!this._sourcesContents) {\n                return null;\n            }\n            if (aSourceRoot != null) {\n                source = util.relative(aSourceRoot, source);\n            }\n            var key = util.toSetString(source);\n            return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;\n        }, this);\n    };\n    SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {\n        var map = {\n            version: this._version,\n            sources: this._sources.toArray(),\n            names: this._names.toArray(),\n            mappings: this._serializeMappings()\n        };\n        if (this._file != null) {\n            map.file = this._file;\n        }\n        if (this._sourceRoot != null) {\n            map.sourceRoot = this._sourceRoot;\n        }\n        if (this._sourcesContents) {\n            map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);\n        }\n        return map;\n    };\n    SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {\n        return JSON.stringify(this.toJSON());\n    };\n\n    return SourceMapGenerator;\n\n});\ndefine('skylark-sourcemap/source-node',[\n    './source-map-generator',\n    './util'\n], function (SourceMapGenerator, util) {\n    'use strict';\n    var REGEX_NEWLINE = /(\\r?\\n)/;\n    var NEWLINE_CODE = 10;\n    var isSourceNode = '$$$isSourceNode$$$';\n    function SourceNode(aLine, aColumn, aSource, aChunks, aName) {\n        this.children = [];\n        this.sourceContents = {};\n        this.line = aLine == null ? null : aLine;\n        this.column = aColumn == null ? null : aColumn;\n        this.source = aSource == null ? null : aSource;\n        this.name = aName == null ? null : aName;\n        this[isSourceNode] = true;\n        if (aChunks != null)\n            this.add(aChunks);\n    }\n    SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n        var node = new SourceNode();\n        var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n        var remainingLinesIndex = 0;\n        var shiftNextLine = function () {\n            var lineContents = getNextLine();\n            var newLine = getNextLine() || '';\n            return lineContents + newLine;\n            function getNextLine() {\n                return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : undefined;\n            }\n        };\n        var lastGeneratedLine = 1, lastGeneratedColumn = 0;\n        var lastMapping = null;\n        aSourceMapConsumer.eachMapping(function (mapping) {\n            if (lastMapping !== null) {\n                if (lastGeneratedLine < mapping.generatedLine) {\n                    addMappingWithCode(lastMapping, shiftNextLine());\n                    lastGeneratedLine++;\n                    lastGeneratedColumn = 0;\n                } else {\n                    var nextLine = remainingLines[remainingLinesIndex] || '';\n                    var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);\n                    remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);\n                    lastGeneratedColumn = mapping.generatedColumn;\n                    addMappingWithCode(lastMapping, code);\n                    lastMapping = mapping;\n                    return;\n                }\n            }\n            while (lastGeneratedLine < mapping.generatedLine) {\n                node.add(shiftNextLine());\n                lastGeneratedLine++;\n            }\n            if (lastGeneratedColumn < mapping.generatedColumn) {\n                var nextLine = remainingLines[remainingLinesIndex] || '';\n                node.add(nextLine.substr(0, mapping.generatedColumn));\n                remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);\n                lastGeneratedColumn = mapping.generatedColumn;\n            }\n            lastMapping = mapping;\n        }, this);\n        if (remainingLinesIndex < remainingLines.length) {\n            if (lastMapping) {\n                addMappingWithCode(lastMapping, shiftNextLine());\n            }\n            node.add(remainingLines.splice(remainingLinesIndex).join(''));\n        }\n        aSourceMapConsumer.sources.forEach(function (sourceFile) {\n            var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n            if (content != null) {\n                if (aRelativePath != null) {\n                    sourceFile = util.join(aRelativePath, sourceFile);\n                }\n                node.setSourceContent(sourceFile, content);\n            }\n        });\n        return node;\n        function addMappingWithCode(mapping, code) {\n            if (mapping === null || mapping.source === undefined) {\n                node.add(code);\n            } else {\n                var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;\n                node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));\n            }\n        }\n    };\n    SourceNode.prototype.add = function SourceNode_add(aChunk) {\n        if (Array.isArray(aChunk)) {\n            aChunk.forEach(function (chunk) {\n                this.add(chunk);\n            }, this);\n        } else if (aChunk[isSourceNode] || typeof aChunk === 'string') {\n            if (aChunk) {\n                this.children.push(aChunk);\n            }\n        } else {\n            throw new TypeError('Expected a SourceNode, string, or an array of SourceNodes and strings. Got ' + aChunk);\n        }\n        return this;\n    };\n    SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\n        if (Array.isArray(aChunk)) {\n            for (var i = aChunk.length - 1; i >= 0; i--) {\n                this.prepend(aChunk[i]);\n            }\n        } else if (aChunk[isSourceNode] || typeof aChunk === 'string') {\n            this.children.unshift(aChunk);\n        } else {\n            throw new TypeError('Expected a SourceNode, string, or an array of SourceNodes and strings. Got ' + aChunk);\n        }\n        return this;\n    };\n    SourceNode.prototype.walk = function SourceNode_walk(aFn) {\n        var chunk;\n        for (var i = 0, len = this.children.length; i < len; i++) {\n            chunk = this.children[i];\n            if (chunk[isSourceNode]) {\n                chunk.walk(aFn);\n            } else {\n                if (chunk !== '') {\n                    aFn(chunk, {\n                        source: this.source,\n                        line: this.line,\n                        column: this.column,\n                        name: this.name\n                    });\n                }\n            }\n        }\n    };\n    SourceNode.prototype.join = function SourceNode_join(aSep) {\n        var newChildren;\n        var i;\n        var len = this.children.length;\n        if (len > 0) {\n            newChildren = [];\n            for (i = 0; i < len - 1; i++) {\n                newChildren.push(this.children[i]);\n                newChildren.push(aSep);\n            }\n            newChildren.push(this.children[i]);\n            this.children = newChildren;\n        }\n        return this;\n    };\n    SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\n        var lastChild = this.children[this.children.length - 1];\n        if (lastChild[isSourceNode]) {\n            lastChild.replaceRight(aPattern, aReplacement);\n        } else if (typeof lastChild === 'string') {\n            this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n        } else {\n            this.children.push(''.replace(aPattern, aReplacement));\n        }\n        return this;\n    };\n    SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\n        this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n    };\n    SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {\n        for (var i = 0, len = this.children.length; i < len; i++) {\n            if (this.children[i][isSourceNode]) {\n                this.children[i].walkSourceContents(aFn);\n            }\n        }\n        var sources = Object.keys(this.sourceContents);\n        for (var i = 0, len = sources.length; i < len; i++) {\n            aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n        }\n    };\n    SourceNode.prototype.toString = function SourceNode_toString() {\n        var str = '';\n        this.walk(function (chunk) {\n            str += chunk;\n        });\n        return str;\n    };\n    SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\n        var generated = {\n            code: '',\n            line: 1,\n            column: 0\n        };\n        var map = new SourceMapGenerator(aArgs);\n        var sourceMappingActive = false;\n        var lastOriginalSource = null;\n        var lastOriginalLine = null;\n        var lastOriginalColumn = null;\n        var lastOriginalName = null;\n        this.walk(function (chunk, original) {\n            generated.code += chunk;\n            if (original.source !== null && original.line !== null && original.column !== null) {\n                if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {\n                    map.addMapping({\n                        source: original.source,\n                        original: {\n                            line: original.line,\n                            column: original.column\n                        },\n                        generated: {\n                            line: generated.line,\n                            column: generated.column\n                        },\n                        name: original.name\n                    });\n                }\n                lastOriginalSource = original.source;\n                lastOriginalLine = original.line;\n                lastOriginalColumn = original.column;\n                lastOriginalName = original.name;\n                sourceMappingActive = true;\n            } else if (sourceMappingActive) {\n                map.addMapping({\n                    generated: {\n                        line: generated.line,\n                        column: generated.column\n                    }\n                });\n                lastOriginalSource = null;\n                sourceMappingActive = false;\n            }\n            for (var idx = 0, length = chunk.length; idx < length; idx++) {\n                if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n                    generated.line++;\n                    generated.column = 0;\n                    if (idx + 1 === length) {\n                        lastOriginalSource = null;\n                        sourceMappingActive = false;\n                    } else if (sourceMappingActive) {\n                        map.addMapping({\n                            source: original.source,\n                            original: {\n                                line: original.line,\n                                column: original.column\n                            },\n                            generated: {\n                                line: generated.line,\n                                column: generated.column\n                            },\n                            name: original.name\n                        });\n                    }\n                } else {\n                    generated.column++;\n                }\n            }\n        });\n        this.walkSourceContents(function (sourceFile, sourceContent) {\n            map.setSourceContent(sourceFile, sourceContent);\n        });\n        return {\n            code: generated.code,\n            map: map\n        };\n    };\n\n    return SourceNode;\n});\ndefine('skylark-sourcemap/main',[\r\n    './array-set',\r\n    './base64-vlq',\r\n    './binary-search',\r\n    './mapping-list',\r\n    './quick-sort',\r\n    \"./source-map-consumer\",\r\n    \"./source-map-generator\",\r\n    \"./source-node\",\r\n    './util',\r\n ], function (\r\n \tArraySet,\r\n \tbase64VLQ, \r\n \tbinarySearch, \r\n \tMappingList, \r\n \tquickSort,\r\n \tconsumers,\r\n \tSourceMapGenerator,\r\n \tSourceNode,\r\n \tutil\r\n ) {\r\n    'use strict';\r\n\r\n    return {\r\n\t \tArraySet,\r\n\t \tbase64VLQ, \r\n\t \tbinarySearch, \r\n\t \tMappingList, \r\n\t \tquickSort,\r\n\t \tconsumers,\r\n\t \tSourceMapGenerator,\r\n\t \tSourceNode,\r\n\t \tutil\r\n    };\r\n\t\r\n});\ndefine('skylark-sourcemap', ['skylark-sourcemap/main'], function (main) { return main; });\n\n"]}