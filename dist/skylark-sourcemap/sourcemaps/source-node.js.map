{"version":3,"sources":["source-node.js"],"names":["define","SourceMapGenerator","util","REGEX_NEWLINE","isSourceNode","SourceNode","aLine","aColumn","aSource","aChunks","aName","this","children","sourceContents","line","column","source","name","add","fromStringWithSourceMap","aGeneratedCode","aSourceMapConsumer","aRelativePath","node","remainingLines","split","remainingLinesIndex","shiftNextLine","getNextLine","length","undefined","lastGeneratedLine","lastGeneratedColumn","lastMapping","eachMapping","mapping","generatedLine","code","nextLine","substr","generatedColumn","addMappingWithCode","splice","join","sources","forEach","sourceFile","content","sourceContentFor","setSourceContent","originalLine","originalColumn","prototype","aChunk","Array","isArray","chunk","TypeError","push","prepend","i","unshift","walk","aFn","len","aSep","newChildren","replaceRight","aPattern","aReplacement","lastChild","replace","aSourceFile","aSourceContent","toSetString","walkSourceContents","Object","keys","fromSetString","toString","str","toStringWithSourceMap","aArgs","generated","map","sourceMappingActive","lastOriginalSource","lastOriginalLine","lastOriginalColumn","lastOriginalName","original","addMapping","idx","charCodeAt","sourceContent"],"mappings":"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","file":"../source-node.js","sourcesContent":["define([\n    './source-map-generator',\n    './util'\n], function (SourceMapGenerator, util) {\n    'use strict';\n    var REGEX_NEWLINE = /(\\r?\\n)/;\n    var NEWLINE_CODE = 10;\n    var isSourceNode = '$$$isSourceNode$$$';\n    function SourceNode(aLine, aColumn, aSource, aChunks, aName) {\n        this.children = [];\n        this.sourceContents = {};\n        this.line = aLine == null ? null : aLine;\n        this.column = aColumn == null ? null : aColumn;\n        this.source = aSource == null ? null : aSource;\n        this.name = aName == null ? null : aName;\n        this[isSourceNode] = true;\n        if (aChunks != null)\n            this.add(aChunks);\n    }\n    SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n        var node = new SourceNode();\n        var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n        var remainingLinesIndex = 0;\n        var shiftNextLine = function () {\n            var lineContents = getNextLine();\n            var newLine = getNextLine() || '';\n            return lineContents + newLine;\n            function getNextLine() {\n                return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : undefined;\n            }\n        };\n        var lastGeneratedLine = 1, lastGeneratedColumn = 0;\n        var lastMapping = null;\n        aSourceMapConsumer.eachMapping(function (mapping) {\n            if (lastMapping !== null) {\n                if (lastGeneratedLine < mapping.generatedLine) {\n                    addMappingWithCode(lastMapping, shiftNextLine());\n                    lastGeneratedLine++;\n                    lastGeneratedColumn = 0;\n                } else {\n                    var nextLine = remainingLines[remainingLinesIndex] || '';\n                    var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);\n                    remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);\n                    lastGeneratedColumn = mapping.generatedColumn;\n                    addMappingWithCode(lastMapping, code);\n                    lastMapping = mapping;\n                    return;\n                }\n            }\n            while (lastGeneratedLine < mapping.generatedLine) {\n                node.add(shiftNextLine());\n                lastGeneratedLine++;\n            }\n            if (lastGeneratedColumn < mapping.generatedColumn) {\n                var nextLine = remainingLines[remainingLinesIndex] || '';\n                node.add(nextLine.substr(0, mapping.generatedColumn));\n                remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);\n                lastGeneratedColumn = mapping.generatedColumn;\n            }\n            lastMapping = mapping;\n        }, this);\n        if (remainingLinesIndex < remainingLines.length) {\n            if (lastMapping) {\n                addMappingWithCode(lastMapping, shiftNextLine());\n            }\n            node.add(remainingLines.splice(remainingLinesIndex).join(''));\n        }\n        aSourceMapConsumer.sources.forEach(function (sourceFile) {\n            var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n            if (content != null) {\n                if (aRelativePath != null) {\n                    sourceFile = util.join(aRelativePath, sourceFile);\n                }\n                node.setSourceContent(sourceFile, content);\n            }\n        });\n        return node;\n        function addMappingWithCode(mapping, code) {\n            if (mapping === null || mapping.source === undefined) {\n                node.add(code);\n            } else {\n                var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;\n                node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));\n            }\n        }\n    };\n    SourceNode.prototype.add = function SourceNode_add(aChunk) {\n        if (Array.isArray(aChunk)) {\n            aChunk.forEach(function (chunk) {\n                this.add(chunk);\n            }, this);\n        } else if (aChunk[isSourceNode] || typeof aChunk === 'string') {\n            if (aChunk) {\n                this.children.push(aChunk);\n            }\n        } else {\n            throw new TypeError('Expected a SourceNode, string, or an array of SourceNodes and strings. Got ' + aChunk);\n        }\n        return this;\n    };\n    SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\n        if (Array.isArray(aChunk)) {\n            for (var i = aChunk.length - 1; i >= 0; i--) {\n                this.prepend(aChunk[i]);\n            }\n        } else if (aChunk[isSourceNode] || typeof aChunk === 'string') {\n            this.children.unshift(aChunk);\n        } else {\n            throw new TypeError('Expected a SourceNode, string, or an array of SourceNodes and strings. Got ' + aChunk);\n        }\n        return this;\n    };\n    SourceNode.prototype.walk = function SourceNode_walk(aFn) {\n        var chunk;\n        for (var i = 0, len = this.children.length; i < len; i++) {\n            chunk = this.children[i];\n            if (chunk[isSourceNode]) {\n                chunk.walk(aFn);\n            } else {\n                if (chunk !== '') {\n                    aFn(chunk, {\n                        source: this.source,\n                        line: this.line,\n                        column: this.column,\n                        name: this.name\n                    });\n                }\n            }\n        }\n    };\n    SourceNode.prototype.join = function SourceNode_join(aSep) {\n        var newChildren;\n        var i;\n        var len = this.children.length;\n        if (len > 0) {\n            newChildren = [];\n            for (i = 0; i < len - 1; i++) {\n                newChildren.push(this.children[i]);\n                newChildren.push(aSep);\n            }\n            newChildren.push(this.children[i]);\n            this.children = newChildren;\n        }\n        return this;\n    };\n    SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\n        var lastChild = this.children[this.children.length - 1];\n        if (lastChild[isSourceNode]) {\n            lastChild.replaceRight(aPattern, aReplacement);\n        } else if (typeof lastChild === 'string') {\n            this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n        } else {\n            this.children.push(''.replace(aPattern, aReplacement));\n        }\n        return this;\n    };\n    SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\n        this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n    };\n    SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {\n        for (var i = 0, len = this.children.length; i < len; i++) {\n            if (this.children[i][isSourceNode]) {\n                this.children[i].walkSourceContents(aFn);\n            }\n        }\n        var sources = Object.keys(this.sourceContents);\n        for (var i = 0, len = sources.length; i < len; i++) {\n            aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n        }\n    };\n    SourceNode.prototype.toString = function SourceNode_toString() {\n        var str = '';\n        this.walk(function (chunk) {\n            str += chunk;\n        });\n        return str;\n    };\n    SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\n        var generated = {\n            code: '',\n            line: 1,\n            column: 0\n        };\n        var map = new SourceMapGenerator(aArgs);\n        var sourceMappingActive = false;\n        var lastOriginalSource = null;\n        var lastOriginalLine = null;\n        var lastOriginalColumn = null;\n        var lastOriginalName = null;\n        this.walk(function (chunk, original) {\n            generated.code += chunk;\n            if (original.source !== null && original.line !== null && original.column !== null) {\n                if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {\n                    map.addMapping({\n                        source: original.source,\n                        original: {\n                            line: original.line,\n                            column: original.column\n                        },\n                        generated: {\n                            line: generated.line,\n                            column: generated.column\n                        },\n                        name: original.name\n                    });\n                }\n                lastOriginalSource = original.source;\n                lastOriginalLine = original.line;\n                lastOriginalColumn = original.column;\n                lastOriginalName = original.name;\n                sourceMappingActive = true;\n            } else if (sourceMappingActive) {\n                map.addMapping({\n                    generated: {\n                        line: generated.line,\n                        column: generated.column\n                    }\n                });\n                lastOriginalSource = null;\n                sourceMappingActive = false;\n            }\n            for (var idx = 0, length = chunk.length; idx < length; idx++) {\n                if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n                    generated.line++;\n                    generated.column = 0;\n                    if (idx + 1 === length) {\n                        lastOriginalSource = null;\n                        sourceMappingActive = false;\n                    } else if (sourceMappingActive) {\n                        map.addMapping({\n                            source: original.source,\n                            original: {\n                                line: original.line,\n                                column: original.column\n                            },\n                            generated: {\n                                line: generated.line,\n                                column: generated.column\n                            },\n                            name: original.name\n                        });\n                    }\n                } else {\n                    generated.column++;\n                }\n            }\n        });\n        this.walkSourceContents(function (sourceFile, sourceContent) {\n            map.setSourceContent(sourceFile, sourceContent);\n        });\n        return {\n            code: generated.code,\n            map: map\n        };\n    };\n\n    return SourceNode;\n});"]}